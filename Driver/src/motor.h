#ifndef MOTOR_H
#define MOTOR_H

//************************ ОБЬЯВЛЕНИЕ ФУНКЦИЙ *******************************************
void set_odom_impuls(int8_t odom_dir_, int16_t &odom_impuls_); // Считаем одометрию Амперсанд перед переменной значит ссылка на нее
void IRAM_ATTR onTimer1();                                     // Обработчик прерывания таймера 0 по совпадению A // Функция исполняемая по прерыванию по таймеру 1 ЛЕВЫЙ МОТОР
void IRAM_ATTR onTimer2();                                     // Обработчик прерывания таймера 0 по совпадению A // Функция исполняемая по прерыванию по таймеру 2 ПРАВЫЙ МОТОР
float chekRPS(float _rps);                                     // Проверка и ограничение минимальной и максимальной частоты вращения. Если меньше минимума то считаем что ноль

void setSpeed_L(float _speed); // Функция устанавлявающая скорость вращения на правом моторе
void setSpeed_R(float _speed); // Функция устанавлявающая скорость вращения на правом моторе

void initTimer_1();  // Инициализация таймера 1. Всего 4 таймера вроде от 0 до 3 //https://techtutorialsx.com/2017/10/07/esp32-arduino-timer-interrupts/
void initTimer_2();  // Инициализация таймера 1. Всего 4 таймера вроде от 0 до 3 //https://techtutorialsx.com/2017/10/07/esp32-arduino-timer-interrupts/
void initMotor();    // Инициализация пинов моторов и установка начальных значений
void testMotor();    // Функция тестирования правильности подключения моторов.
void delayMotor();   // Функция задержки выключения моторов после команды стоп на 1 секунду для экономии энергии и чтобы не грелись
void movementTime(); // Функция отслеживает время движения. Движемся только опредленное время и потом если нет новой команды останавливаемся
void calcEncod();    // Функция обсчета телеметрии колес. перобразуем ипульсы в метры пройденного пути с учетом направления вращения
//***************************************************************************************
//---------------------------------------------------------------------------------------
#define PIN_En 14     // Пин включения драйвера мотора
#define PIN_L_Step 26 //
#define PIN_L_Dir 12  //
#define PIN_R_Step 32 //
#define PIN_R_Dir 33  //
//---------------------------------------------------------------------------------------
#define Pla_PIN_En 4      // Пин включения драйвера мотора платформы
#define Pla_PIN_L_Step 27 //
#define Pla_PIN_L_Dir 13  //
#define Pla_PIN_R_Step 16 //
#define Pla_PIN_R_Dir 17  //
//---------------------------------------------------------------------------------------
#define MAX_RPS 2.0       // максимальная скорость колеса (в оборотах в секунду)
#define SPEED_PLA_RPS 1.0 // скорость вращеия моторов платформы (в оборотах в секунду)

bool flag_motor_L_EN = 0; // Флаг работает или нет Левый мотор
bool flag_motor_R_EN = 0; // Флаг работает или нет Правый мотор

bool flag_motor_PLA_L = 0; // Флаг работает или нет Левый мотор платформы
bool flag_motor_PLA_R = 0; // Флаг работает или нет Правый мотор платформы

uint64_t time_command_motor = 0; // Время в которое дали команду остановиться моторам

int microStep;        // Число микрошагов
int Timeing_Step_L;   // Число тактов для таймера через которое нужно дать новый имульс мотору
int Timeing_Step_R;   // Число тактов для таймера через которое нужно дать новый имульс мотору
int Timeing_Step_Pla; // Число тактов для таймера через которое нужно дать новый имульс мотору на платформе. Они с одинаковой скоростью

// Одометрия
float rps_R_gived = 0; // Скорость на моторе желаемаая rpm
float rps_R_odom = 0;  // Скорость на моторе на основе одометрии по импульсам rpm

float rps_L_gived = 0; // Скорость на моторе желаемаая rpm
float rps_L_odom = 0;  // Скорость на моторе на основе одометрии по импульсам rpm

int16_t odom_impuls_L = 0; // Количество ипульсов переданных колесу с учетом направления вращения
int16_t odom_impuls_R = 0; // Количество ипульсов переданных колесу с учетом направления вращения

int8_t odom_dir_L = 0; // Направление вращения левого колеса в данный момент 1- вперед, -1 - назад, 0 стоим на месте
int8_t odom_dir_R = 0; // Направление вращения правого колеса в данный момент 1- вперед, -1 - назад, 0 стоим на месте

uint64_t timeExecuteCommand = 0; // время в который момент начали движение
bool flagExecuteCommand = 0;     // Флаг что надо отслеживать движение по времени

// Считаем одометрию Амперсанд перед переменной значит ссылка на нее
void set_odom_impuls(int8_t odom_dir_, int16_t &odom_impuls_)
{
    if (odom_dir_ == 1)
    {
        odom_impuls_++;
    }
    if (odom_dir_ == -1)
    {
        odom_impuls_--;
    }
}
// Функция исполняемая по прерыванию по таймеру 1 ЛЕВЫЙ МОТОР
void IRAM_ATTR onTimer1() // Обработчик прерывания таймера 0 по совпадению A
{
    if (flag_motor_L_EN) // Если флаг вращения моторов включен тогда делаем импульс
    {
        digitalWrite(PIN_L_Step, 1);
        delayMicroseconds(1);
        timerAlarmWrite(timer1, Timeing_Step_L, true); // Устанавливаем период прерывания по таймеру
        set_odom_impuls(odom_dir_L, odom_impuls_L);    // Считаем ипульсы для одометрии типа как энкодер
        digitalWrite(PIN_L_Step, 0);
    }
}
// Функция исполняемая по прерыванию по таймеру 2 ПРАВЫЙ МОТОР
void IRAM_ATTR onTimer2() // Обработчик прерывания таймера 0 по совпадению A
{
    if (flag_motor_R_EN) // Если флаг вращения моторов включен тогда делаем импульс
    {
        digitalWrite(PIN_R_Step, 1);
        delayMicroseconds(1);
        timerAlarmWrite(timer2, Timeing_Step_R, true); // Устанавливаем период прерывания по таймеру
        set_odom_impuls(odom_dir_R, odom_impuls_R);    // Считаем ипульсы для одометрии типа как энкодер
        digitalWrite(PIN_R_Step, 0);
    }
}
// Функция исполняемая по прерыванию по таймеру 3 ОБА МОТОРА НА ПЛАТФОРМУ
void IRAM_ATTR onTimer3() // Обработчик прерывания таймера 0 по совпадению A
{
    timerAlarmWrite(timer3, Timeing_Step_Pla, true); // Устанавливаем период прерывания по таймеру
    if (flag_motor_PLA_L)                              // Если флаг вращения моторов включен тогда делаем импульс
    {
        digitalWrite(Pla_PIN_L_Step, 1);
    }
    if (flag_motor_PLA_R)                              // Если флаг вращения моторов включен тогда делаем импульс
    {
        digitalWrite(Pla_PIN_R_Step, 1);
    }
        delayMicroseconds(1);
        digitalWrite(Pla_PIN_L_Step, 0);
        digitalWrite(Pla_PIN_R_Step, 0);
}
// Проверка и ограничение минимальной и максимальной частоты вращения. Если меньше минимума то считаем что ноль
float chekRPS(float _rps)
{
    if (_rps > 0 && _rps < 0.002)
        _rps = 0;
    if (_rps < 0 && _rps > -0.002)
        _rps = 0;
    if (_rps > MAX_RPS)
        _rps = MAX_RPS;
    if (_rps < -MAX_RPS)
        _rps = -MAX_RPS;
    return _rps;
}

// Функция устанавлявающая скорость вращения на правом моторе скорость в rps
void setSpeed_L(float speed_)
{
    time_command_motor = millis(); // Запоминаем время когда выполнили любую команду по управлением скоростью мотора. Потом если пройдет время отключим драйвера delayMotor()
    float step_za_sec = 0;
    float rps = chekRPS(speed_); // Проверка минимального и максимального rps
    if (rps != 0)                // Если не задано что ноль, то считаем начальную скорость и смотрим куда едем
    {
        digitalWrite(PIN_En, 0); // Включаем драйвера
        if (rps < 0)             // Задаем направление вращения
        {
            digitalWrite(PIN_L_Dir, 1);
            odom_dir_L = -1; // Тут назначаем куда вращаемся для одометрии для левого и правого колеса может быть надо по разному
        }
        if (rps > 0)
        {
            digitalWrite(PIN_L_Dir, 0);
            odom_dir_L = 1; // Тут назначаем куда вращаемся для одометрии для левого и правого колеса может быть надо по разному
        }
        rps = abs(rps);                                                  // После того как определили направление, дальше считаем по модулю
        step_za_sec = (rps * 360 / 1.8) * REDUCTOR;                      // Берем обороты их умножаем на градусы и делим на градус на 1 шаг и умножаем на коэффициент редуктора получаем нужное число полных шагов для такой скорости за секунду
        Timeing_Step_L = (float)1000000 / step_za_sec / microStep / 1.0; // Таймер по 1 микросекунде// Микросекунды в секунде делим на число шагов которые надо успеть сделать за секунду и делим на микрошаги делим на микросекунды за 1 шаг с учетом предделителя таймера
        flag_motor_L_EN = true;                                          // Взводим флаг разрешающий делать импульсы в обработчике прерывания
    }
    else
    {
        flag_motor_L_EN = false; // Флаг ставим что мотор не работает это чтобы импульс не подавался
    }
    // printf("%lu setSpeed_L= %f -> rpsL=  %.3f -> step_za_sec L = %.3f  -> Timeing_Step_L = %i \n", millis(), _speed, rps, step_za_sec, Timeing_Step_L);
    // printf("%lu speedL %f rps %.3f stepSec %.3f TStep %i \n", millis(), _speed, rps, step_za_sec, Timeing_Step_L);
}
// Функция устанавлявающая скорость вращения на правом моторе
void setSpeed_R(float speed_)
{
    time_command_motor = millis(); // Запоминаем время когда выполнили любую команду по управлением скоростью мотора. Потом если пройдет время отключим драйвера delayMotor()
    float step_za_sec = 0;
    float rps = chekRPS(speed_); // Проверка минимального rps
    if (rps != 0)                // Если не задано что ноль, то считаем начальную скорость и смотрим куда едем
    {
        digitalWrite(PIN_En, 0); // Включаем драйвера
        if (rps < 0)             // Задаем направление вращения
        {
            digitalWrite(PIN_R_Dir, 0);
            odom_dir_R = -1; // Тут назначаем куда вращаемся для одометрии для левого и правого колеса может быть надо по разному
        }
        if (rps > 0)
        {
            digitalWrite(PIN_R_Dir, 1);
            odom_dir_R = 1; // Тут назначаем куда вращаемся для одометрии для левого и правого колеса может быть надо по разному
        }
        rps = abs(rps);                                                  // После того как определили направление, дальше считаем по модулю
        step_za_sec = (rps * 360 / 1.8) * REDUCTOR;                      // Берем обороты их умножаем на градусы и делим на градус на 1 шаг  умножаем на коэффициент редуктора  получаем нужное число полных шагов для такой скорости за секунду
        Timeing_Step_R = (float)1000000 / step_za_sec / microStep / 1.0; // Таймер по 1 микросекунде// Микросекунды в секунде делим на число шагов которые надо успеть сделать за секунду и делим на микрошаги делим на микросекунды за 1 шаг с учетом предделителя таймера
        flag_motor_R_EN = true;                                          // Взводим флаг разрешающий делать импульсы в обработчике прерывания
    }
    else
    {
        flag_motor_R_EN = false; // Флаг ставим что мотор не работает это чтобы импульс не подавался
    }
    // printf("%lu setSpeed_R= %f -> rpsR=  %.3f -> step_za_sec R = %.3f  -> Timeing_Step_R = %i \n", millis(), _speed, rps, step_za_sec, Timeing_Step_R);
    // printf("%lu speedR %f rps %.3f stepSec %.3f TStep %i \n", millis(), _speed, rps, step_za_sec, Timeing_Step_R);
}

// Инициализация таймера 1. Всего 4 таймера вроде от 0 до 3 //https://techtutorialsx.com/2017/10/07/esp32-arduino-timer-interrupts/
void initTimer_1()
{
    timer1 = timerBegin(1, 80, true);              // Номер таймера, делитель(прескаллер), Считать вверх, прибавлять (true)  Частота базового сигнала 80  Мега герц, значит будет 1 микросекунда
    timerAttachInterrupt(timer1, &onTimer1, true); // Какой таймер используем, какую функцию вызываем,  тип прерывания  edge или level interrupts
    timerAlarmWrite(timer1, 100000, true);         // Какой таймер, до скольки считаем , сбрасываем ли счетчик при срабатывании. 1000 микросекунд эти 1 милисекунда
    timerAlarmEnable(timer1);                      // Запускаем таймер
    printf("%lu initTimer_1 \n", millis());
}
// Инициализация таймера 1. Всего 4 таймера вроде от 0 до 3 //https://techtutorialsx.com/2017/10/07/esp32-arduino-timer-interrupts/
void initTimer_2()
{
    timer2 = timerBegin(2, 80, true);              // Номер таймера, делитель(прескаллер), Считать вверх, прибавлять (true)  Частота базового сигнала 80  Мега герц, значит будет 1 микросекунда
    timerAttachInterrupt(timer2, &onTimer2, true); // Какой таймер используем, какую функцию вызываем,  тип прерывания  edge или level interrupts
    timerAlarmWrite(timer2, 100000, true);         // Какой таймер, до скольки считаем , сбрасываем ли счетчик при срабатывании. 1000 микросекунд эти 1 милисекунда
    timerAlarmEnable(timer2);                      // Запускаем таймер
    printf("%lu initTimer_2 \n", millis());
}
// Инициализация таймера 3. Всего 4 таймера вроде от 0 до 3 //https://techtutorialsx.com/2017/10/07/esp32-arduino-timer-interrupts/
void initTimer_3()
{
    timer3 = timerBegin(3, 80, true);              // Номер таймера, делитель(прескаллер), Считать вверх, прибавлять (true)  Частота базового сигнала 80  Мега герц, значит будет 1 микросекунда
    timerAttachInterrupt(timer3, &onTimer3, true); // Какой таймер используем, какую функцию вызываем,  тип прерывания  edge или level interrupts
    timerAlarmWrite(timer3, 100000, true);         // Какой таймер, до скольки считаем , сбрасываем ли счетчик при срабатывании. 1000 микросекунд эти 1 милисекунда

    float rps = abs(SPEED_PLA_RPS);                                    // После того как определили направление, дальше считаем по модулю
    float step_za_sec = (rps * 360 / 1.8);                             // Берем обороты их умножаем на градусы и делим на градус на 1 шаг получаем нужное число полных шагов для такой скорости за секунду
    Timeing_Step_Pla = (float)1000000 / step_za_sec / microStep / 1.0; // Таймер по 1 микросекунде// Микросекунды в секунде делим на число шагов которые надо успеть сделать за секунду и делим на микрошаги делим на микросекунды за 1 шаг с учетом предделителя таймера
    timerAlarmWrite(timer3, Timeing_Step_Pla, true);                   // Устанавливаем период прерывания по таймеру

    timerAlarmEnable(timer3); // Запускаем таймер
    printf("%lu initTimer_3 Timeing_Step_Pla= %i \n", millis(), Timeing_Step_Pla);
}

// Инициализация пинов моторов и установка начальных значений
void initMotor()
{
    microStep = 8; // Так распаяно на плате для драйверов 2208 и 2209
    //**************************************************************   Мотор на колеса
    pinMode(PIN_En, OUTPUT);
    digitalWrite(PIN_En, 1); // 0- Разрешена работа 1- запрещена работа драйвера

    pinMode(PIN_L_Step, OUTPUT); // Устанавливаем пины для левого мотора
    digitalWrite(PIN_L_Step, 0); // Подтяжка чтобы не в воздухе
    pinMode(PIN_L_Dir, OUTPUT);
    digitalWrite(PIN_L_Dir, 0); //  Подтяжка чтобы не в воздухе сделал резистором на плате что-бы при перезагрузке не дергалось

    pinMode(PIN_R_Step, OUTPUT); // Устанавливаем пины для правого мотора
    digitalWrite(PIN_R_Step, 0); // Подтяжка чтобы не в воздухе
    pinMode(PIN_R_Dir, OUTPUT);
    digitalWrite(PIN_R_Dir, 0); //  Подтяжка чтобы не в воздухе сделал резистором на плате что-бы при перезагрузке не дергалось

    //**************************************************************   Мотор на платформу
    pinMode(Pla_PIN_En, OUTPUT);
    digitalWrite(Pla_PIN_En, 1); // 0- Разрешена работа 1- запрещена работа драйвера

    pinMode(Pla_PIN_L_Step, OUTPUT); // Устанавливаем пины для левого мотора
    digitalWrite(Pla_PIN_L_Step, 0); // Подтяжка чтобы не в воздухе
    pinMode(Pla_PIN_L_Dir, OUTPUT);
    digitalWrite(Pla_PIN_L_Dir, 0); //  Подтяжка чтобы не в воздухе сделал резистором на плате что-бы при перезагрузке не дергалось

    pinMode(Pla_PIN_R_Step, OUTPUT); // Устанавливаем пины для правого мотора
    digitalWrite(Pla_PIN_R_Step, 0); // Подтяжка чтобы не в воздухе
    pinMode(Pla_PIN_R_Dir, OUTPUT);
    digitalWrite(Pla_PIN_R_Dir, 0); //  Подтяжка чтобы не в воздухе сделал резистором на плате что-бы при перезагрузке не дергалось
    //****************************************************************

    flag_motor_L_EN = false; // Флаг ставим что мотор не работает, просто перестаем делать импульсы
    flag_motor_R_EN = false; // Флаг ставим что мотор не работает, просто перестаем делать импульсы

    printf("%lu Init StepMotor. Set microstep = %i \n", millis(), microStep);

    initTimer_1(); // Таймер на 1 мотор
    initTimer_2(); // Таймер на 2 мотор
    initTimer_3(); // Таймер на 2 мотор
}
// Функция отслеживает время движения. Движемся только опредленное время и потом если нет новой команды останавливаемся
void movementTime()
{
    // Отслеживание времени с прихода последней команды по времени
    if (flagExecuteCommand)
    {
        if (millis() - timeExecuteCommand > 1000) // Если секунду нет команд то стоп моторы
        {
            flagExecuteCommand = false; // Заканчиваем отслеживать
            setSpeed_L(0);
            setSpeed_R(0);
        }
    }
}

// Функция тестирования правильности подключения моторов.
void testMotor()
{
    // setSpeed_L(2); // Задаем напрямую скорость вращения обороты в секунду
    for (int i = 0; i < 10; i++)
    {
        setSpeed_L(i / 10.0);
        delay (250);
    }
    for (int i = 0; i < 10; i++)
    {
        setSpeed_R(i / 10.0);
        delay (250);
    }

    //setSpeed_R(1.0);
    while (1)
        ;
}
// Функция задержки выключения моторов после команды стоп на 1 секунду для экономии энергии и чтобы не грелись
void delayMotor()
{
    // Отслеживания времени отключить драйвера на моторах чтобы не грелись и не потребляли энергию
    if (millis() - time_command_motor > 2000) // Если с момента остановки моторов прошло более 2000 милисекунд (2 секунда) и флаг не изменился другой командой
    {
        digitalWrite(PIN_En, 1); // Выключаем драйвера
    }
}

// Функция обсчета телеметрии колес. перобразуем ипульсы в метры пройденного пути с учетом направления вращения
void calcEncod()
{
    static unsigned long time = micros();        // Время предыдущего расчета
    unsigned long time_now = micros();           // Время в которое делаем расчет
    double dt = ((time_now - time) / 1000000.0); // Интервал расчета переводим сразу в секунды
    time = time_now;
    //------------------------------------
    float gradusL = odom_impuls_L * (1.8 / microStep); // На сколько градусов проехали c учетом микрошага драйвера 8
    float gradusR = odom_impuls_R * (1.8 / microStep); // На сколько градусов проехали c учетом микрошага драйвера 8

    odom_impuls_L = 0; // Обнуляем значение
    odom_impuls_R = 0; // Обнуляем значение

    motor.rpsEncodL = (gradusL / dt) / 360.0; // Сколько оборотов сделали
    motor.rpsEncodR = (gradusR / dt) / 360.0; // Сколько оборотов сделали
    motor.statusDriver = digitalRead(PIN_En); // Считываем статус пина драйвера мотора
}

#endif